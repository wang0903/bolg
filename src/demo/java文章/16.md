---
icon: pen-to-square
date: 2025-11-20
category:
  - java
tag:
  - MQ
star: true
sticky: true #标记
---
# 安装rocketmq

##  **系统解耦（Decoupling）**

- **问题**：
  - 传统系统 A 调用系统 B，直接依赖。
  - 如果 B 宕机或响应慢，A 也会受影响。
- **MQ 解决方式**：
  - 生产者把消息发到 MQ，消费者自己去 MQ 消费。
  - 生产者不关心谁消费，也不关心消费速度。
- **制造行业示例**：
  - 生产线设备上报状态 → MQ → MES 或报警系统消费
  - 即使 MES 暂时停机，设备依然可以上报消息，系统不会崩。

------

## **流量削峰填谷（Peak Shaving）**

- **问题**：
  - ERP 或设备在短时间内产生大量消息。
  - 数据库或后端处理系统瞬间承受不了。
- **MQ 解决方式**：
  - 消息先存入 MQ 队列（缓冲区）。
  - 消费端按自己的能力慢慢处理消息。
- **制造行业示例**：
  - 高峰期下 1000 条订单 → MQ 队列缓冲 → MES 慢慢生成工单 → 写数据库

------

## **异步处理（Asynchronous Processing）**

- **问题**：
  - 某些操作不需要立即完成，但又必须可靠执行。
  - 如果同步处理，主流程会被阻塞。
- **MQ 解决方式**：
  - 生产者发送消息后立即返回。
  - 消费端异步处理耗时任务。
- **制造行业示例**：
  - 设备报警 → MQ → 消费端异步处理短信/邮件通知 → 不影响设备采集

------

## **提高可靠性（Reliability & Retry）**

- **问题**：
  - 网络异常或消费端异常可能导致消息丢失。
  - 直接调用接口或写数据库，如果失败，消息就丢了。
- **MQ 解决方式**：
  - 消息持久化到 Broker（CommitLog），保证不会丢失。
  - 支持消费失败重试、事务消息。
- **制造行业示例**：
  - 关键报警或订单消息即使消费失败，MQ 会重试，保证最终处理成功。

------

## MQ总结

> **MQ 设计出来是为了解耦系统、削峰填谷、异步处理和保证消息可靠性**。
>  换句话说，它解决的是**高并发、高耦合、同步阻塞和数据可靠性**的问题，而不是用来存储业务数据。

------

## 编写docker-compose.yml

```yaml
services:
  namesrv:
    image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/apache/rocketmq:5.3.2
    container_name: rmqnamesrv
    ports:
      - 9876:9876
    networks:
      - rocketmq
    volumes:
      - /home/mes/rocketmq/namesrv:/home/rocketmq/logs
    command: ["sh", "-c", "/home/rocketmq/rocketmq-5.3.2/bin/mqnamesrv"]
    restart: unless-stopped

  broker:
    image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/apache/rocketmq:5.3.2
    container_name: rmqbroker
    ports:
      - 10909:10909
      - 10911:10911
      - 10912:10912
    environment:
      - NAMESRV_ADDR=rmqnamesrv:9876
    depends_on:
      - namesrv
    networks:
      - rocketmq
    volumes:
      - /home/mes/rocketmq/store:/home/rocketmq/store
      - /home/mes/rocketmq/broker/broker.conf:/home/rocketmq/broker.conf
    command: ["sh", "-c", "mqbroker -c /home/rocketmq/broker.conf"]
    restart: unless-stopped

  dashboard:
    image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/apacherocketmq/rocketmq-dashboard:latest
    container_name: rocketmq-dashboard
    ports:
      - "8089:8080"
    depends_on:
      - namesrv
    networks:
      - rocketmq
    environment:
      - JAVA_OPTS=-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Drocketmq.config.loginRequired=true -Dspring.security.user.name=admin -Dspring.security.user.password=admin123
   restart: unless-stopped
networks:
  rocketmq:
    driver: bridge

```



## 创建topic名称命令

```sh
docker exec -it rmqbroker sh mqadmin updateTopic \
  -n rmqnamesrv:9876 \
  -t SMS_SEND_TOPIC \
  -c DefaultCluster
```

------

## 原理图片

![Domain Model | RocketMQ](https://rocketmq.apache.org/assets/images/mainarchi-9b036e7ff5133d050950f25838367a17.png)

## 核心角色

| 角色           | 作用                | 说明                              |
| -------------- | ------------------- | --------------------------------- |
| **NameServer** | 注册中心            | Broker 的地址注册、Topic 路由发现 |
| **Broker**     | 消息存储/转发服务器 | 真正存消息（基于 CommitLog）      |
| **Producer**   | 消息生产者          | 发送消息到 Broker                 |
| **Consumer**   | 消息消费者          | 从 Broker 拉取消息                |

## RocketMQ 的消息流转原理（非常重要）

### **① Topic 路由发现**

Producer → NameServer
 Consumer → NameServer
 （拿到 Broker 的地址和 Topic 的队列列表）

### **② Producer 发送消息**

- Producer 会从路由表中选择一个 Queue（比如 round robin）
- 将消息发送到对应 Broker
- Broker 写入 CommitLog（顺序写），性能非常高

### **③ Consumer 拉取消息（Push 其实也是拉）**

- Consumer 每隔一段时间向 Broker 拉取消息（Pull）
- 框架将其封装成 Push 形式（回调）
- Consumer 还会保存消费进度（Offset）

------

## 示例(java)

### Message 消息

```java
@Data
public class SmsSendMessage {

    public static final String TOPIC = "SMS_SEND_TOPIC"; // 重点：需要增加消息对应的 Topic

    /**
     * 短信日志编号
     */
    @NotNull(message = "短信日志编号不能为空")
    private Long logId;
    /**
     * 手机号
     */
    @NotNull(message = "手机号不能为空")
    private String mobile;
    /**
     * 短信渠道编号
     */
    @NotNull(message = "短信渠道编号不能为空")
    private Long channelId;
    /**
     * 短信 API 的模板编号
     */
    @NotNull(message = "短信 API 的模板编号不能为空")
    private String apiTemplateId;
    /**
     * 短信模板参数
     */
    private List<KeyValue<String, Object>> templateParams;

}
```

### SmsProducer 生产者

```java
/**
 * Sms 短信相关消息的 Producer
 *
 * @author zzf
 * @date 2021/3/9 16:35
 */
@Slf4j
@Component
public class SmsProducer {

    @Resource
    private RedisMQTemplate redisMQTemplate;

    @Resource
    private RocketMQTemplate rocketMQTemplate; // 重点：注入 RocketMQTemplate 对象

    /**
     * 发送 {@link SmsChannelRefreshMessage} 消息
     */
    public void sendSmsChannelRefreshMessage() {
        SmsChannelRefreshMessage message = new SmsChannelRefreshMessage();
        redisMQTemplate.send(message);
    }

    /**
     * 发送 {@link SmsTemplateRefreshMessage} 消息
     */
    public void sendSmsTemplateRefreshMessage() {
        SmsTemplateRefreshMessage message = new SmsTemplateRefreshMessage();
        redisMQTemplate.send(message);
    }

    /**
     * 发送 {@link SmsSendMessage} 消息
     *
     * @param logId 短信日志编号
     * @param mobile 手机号
     * @param channelId 渠道编号
     * @param apiTemplateId 短信模板编号
     * @param templateParams 短信模板参数
     */
    public void sendSmsSendMessage(Long logId, String mobile,
                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {
        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);
        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);
        rocketMQTemplate.convertAndSend(SmsSendMessage.TOPIC, message); // 重点：使用 RocketMQTemplate 同步发送消息
    }

}
```

### SmsSendConsumer 消费者

```java
/**
 * 针对 {@link SmsSendMessage} 的消费者
 *
 * @author zzf
 */
@Component
@RocketMQMessageListener(
        topic = SmsSendMessage.TOPIC,
        consumerGroup = SmsSendMessage.TOPIC + "_CONSUMER"
)
@Slf4j
public class SmsSendConsumer implements RocketMQListener<SmsSendMessage> {

    @Resource
    private SmsSendService smsSendService;

    @Override
    public void onMessage(SmsSendMessage message) {
        log.info("[onMessage][消息内容({})]", message);
        smsSendService.doSendSms(message);
    }
}
```

### 测试

```http
### 请求 /system/sms-template/send-sms 接口 => 成功
POST {{baseUrl}}/system/sms-template/send-sms
Authorization: Bearer {{token}}
Content-Type: application/json
tenant-id: {{adminTenentId}}

{
  "templateCode": "test_02",
  "mobile": "15601691390",
  "templateParams": {
    "operation": "登录222",
    "code": "12345633333"
  }
}
```

